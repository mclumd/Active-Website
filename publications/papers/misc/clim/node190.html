<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 99.1 release (March 30, 1999)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Examples of Incremental Redisplay</TITLE>
<META NAME="description" CONTENT="Examples of Incremental Redisplay">
<META NAME="keywords" CONTENT="clim">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.1 release">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="clim.css">

<LINK REL="next" HREF="node191.html">
<LINK REL="previous" HREF="node189.html">
<LINK REL="up" HREF="node189.html">
<LINK REL="next" HREF="node191.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html3327"
 HREF="node191.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/icons/next_motif.gif"></A> 
<A NAME="tex2html3323"
 HREF="node189.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/icons/up_motif.gif"></A> 
<A NAME="tex2html3317"
 HREF="node189.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/icons/previous_motif.gif"></A> 
<A NAME="tex2html3325"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="/icons/contents_motif.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html3328"
 HREF="node191.html">Standard Programmer Interface</A>
<B> Up:</B> <A NAME="tex2html3324"
 HREF="node189.html">Incremental Redisplay</A>
<B> Previous:</B> <A NAME="tex2html3318"
 HREF="node189.html">Incremental Redisplay</A>
 &nbsp <B>  <A NAME="tex2html3326"
 HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION06710000000000000000">
Examples of Incremental Redisplay</A>
</H1>

<P>
The usual technique of incremental redisplay is to use updating-output to
inform CLIM what output has changed, and use redisplay to recompute and
redisplay that output.

<P>
The outermost call to updating-output identifies a program fragment that
produces incrementally redisplayable output.  A nested call to
updating-output (that is, a call to updating-output that occurs during
the execution of the body of the outermost updating-output and specifies
the same stream) identifies an individually redisplayable piece of output, the
program fragment that produces that output, and the circumstances under which
that output needs to be redrawn.

<P>
The outermost call to updating-output executes its body, producing the
initial version of the output, and returns an incremental redisplay record that
captures the body in a closure.  Each nested call to updating-output stores
its :unique-id and :cache-value arguments and the portion of the
output produced by its body.

<P>
redisplay takes an incremental redisplay record and executes the captured
body of updating-output over again.  When a nested call to
updating-output is executed during redisplay, updating-output decides
whether the cached output can be reused or the output needs to be redrawn.  This
is controlled by the :cache-value argument to updating-output.  If its
value matches its previous value, the body would produce output identical to the
previous output and thus is unnecessary.  In this case the cached output is
reused and updating-output does not execute its body.  If the cache value
does not match, the output needs to be redrawn, so updating-output executes
its body and the new output drawn on the stream replaces the previous output.
The :cache-value argument is only meaningful for nested calls to
updating-output.

<P>
In order to compare the cache to the output record, two pieces of information
are necessary:

<P>

<UL>
<LI>An association between the output being done by the program and a
particular cache.  This is supplied in the :unique-id option to
updating-output.

<P>
 </LI>
<LI>A means of determining whether this particular cache is valid.  This is
the :cache-value option to updating-output.</LI>
</UL>

<P>
Normally, the programmer would supply both options. The unique-id would be some
data structure associated with the corresponding part of output.  The cache
value would be something in that data structure that changes whenever the output
changes.

<P>
It is valid to give the :unique-id and not the :cache-value.  This is
done to identify a parent in the hierarchy.  By this means, the children
essentially get a more complex unique id when they are matched for output.  (In
other words, it is like using a telephone area code.)  The cache without a cache
value is never valid.  Its children always have to be checked.

<P>
It is also valid to give the :cache-value and not the :unique-id.  In
this case, unique ids are just assigned sequentially.  So, if output associated
with the same thing is done in the same order each time, it isn't necessary to
invent new unique ids for each piece.  This is especially true in the case of
children of a cache with a unique id and no cache value of its own.  In this
case, the parent marks the particular data structure, whose components can
change individually, and the children are always in the same order and properly
identified by their parent and the order in which they are output.

<P>
A unique id need not be unique across the entire redisplay, only among the
children of a given output cache; that is, among all possible (current and
additional) uses made of updating-output that are dynamically (not
lexically) within another.

<P>
To make incremental redisplay maximally efficient, the programmer should attempt
to give as many caches with :cache-value as possible.  For instance, if the
thing being redisplayed is a deeply nested tree, it is better to be able to know
when whole branches have not changed than to have to recurse to every single
leaf and check it.  So, if there is a modification tick in the leaves, it is
better to also have one in their parent of the leaves and propagate the
modification up when things change.  While the simpler approach works, it
requires CLIM to do more work than is necessary.

<P>
The following function illustrates the standard use of Incremental Redisplay:

<P>
 
<PRE>

(defun test (stream)
  (let* ((list (list 1 2 3 4 5))
         (record
           (updating-output (stream)
             (do* ((elements list (cdr elements))
                   (count 0 (1+ count)))
                  ((null elements))
               (let ((element (first elements)))
                 (updating-output (stream :unique-id count
                                          :cache-value element)
                   (format stream "Element ~D" element)
                   (terpri stream)))))))
    (sleep 10)
    (setf (nth 2 list) 17)
    (redisplay record stream)))
</PRE>

<P>
When this function is run on a window, the initial display will look like:

<P>
 
<PRE>

  Element 1
  Element 2
  Element 3
  Element 4
  Element 5
</PRE>

<P>
After the sleep has terminated, the display will look like:

<P>
 
<PRE>

  Element 1
  Element 2
  Element 17
  Element 4
  Element 5
</PRE>

<P>
Incremental Redisplay takes care of ensuring that only the third line gets
erased and redisplayed.  In the case where items moved around (try the example
substituting

<P>
 
<PRE>

(setf list (sort list #'(lambda (x y)
                          (declare (ignore x y))
                          (zerop (random 2)))))
</PRE>
for the form after the call to sleep), Incremental Redisplay would ensure
that the minimum amount of work would be done in updating the display, thereby
minimizing ``flashiness'' while providing a powerful user interface.

<P>
See the discussion of Application Building Tools elsewhere in this document for
examples of how to use Incremental Redisplay automatically within your
application.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html3327"
 HREF="node191.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/icons/next_motif.gif"></A> 
<A NAME="tex2html3323"
 HREF="node189.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/icons/up_motif.gif"></A> 
<A NAME="tex2html3317"
 HREF="node189.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/icons/previous_motif.gif"></A> 
<A NAME="tex2html3325"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="/icons/contents_motif.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html3328"
 HREF="node191.html">Standard Programmer Interface</A>
<B> Up:</B> <A NAME="tex2html3324"
 HREF="node189.html">Incremental Redisplay</A>
<B> Previous:</B> <A NAME="tex2html3318"
 HREF="node189.html">Incremental Redisplay</A>
 &nbsp <B>  <A NAME="tex2html3326"
 HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>&</I>
<BR><I>2001-06-12</I>
</ADDRESS>
</BODY>
</HTML>
