<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 99.1 release (March 30, 1999)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Rendering Conventions for Geometric Shapes</TITLE>
<META NAME="description" CONTENT="Rendering Conventions for Geometric Shapes">
<META NAME="keywords" CONTENT="clim">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.1 release">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="clim.css">

<LINK REL="next" HREF="node113.html">
<LINK REL="previous" HREF="node110.html">
<LINK REL="up" HREF="node105.html">
<LINK REL="next" HREF="node112.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html2274"
 HREF="node112.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/icons/next_motif.gif"></A> 
<A NAME="tex2html2270"
 HREF="node105.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/icons/up_motif.gif"></A> 
<A NAME="tex2html2264"
 HREF="node110.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/icons/previous_motif.gif"></A> 
<A NAME="tex2html2272"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="/icons/contents_motif.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html2275"
 HREF="node112.html">Permissible Alternatives During Rendering</A>
<B> Up:</B> <A NAME="tex2html2271"
 HREF="node105.html">Graphics</A>
<B> Previous:</B> <A NAME="tex2html2265"
 HREF="node110.html">Drawing is Approximate</A>
 &nbsp <B>  <A NAME="tex2html2273"
 HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION05330000000000000000">
Rendering Conventions for Geometric Shapes</A>
</H1>

<P>
The intent of this section is to describe the conventions for how CLIM should
render a shape on a display device.  These conventions and the accompanying
examples are meant to describe a set of goals that a CLIM implementation should
try to meet.  However, compliant CLIM implementations may deviate from these
goals if necessary (for example, if the rendering performance on a specific
platform would be unacceptably slow if these goals were met exactly and
implementors feel that users would be better served by speed than by accuracy).
Note that we discuss only pixel-based display devices here, which are the most
common, but by no means the only, sort of display device that can be supported
by CLIM.

<P>
When CLIM draws a geometric shape on some sort of display device, the idealized
geometric shape must somehow be rendered on the display device.  The geometric
shapes are made up of a set of mathematical points, which have no size; the
rendering of the shape is usually composed of pixels, which are roughly square.
These pixels exist in ``device coordinates'', which are gotten by transforming
the user-supplied coordinates by all of the user-supplied transformation, the
medium transformation, and the transformation that maps from the sheet to the
display device.  (Note that if the last transformation is a pure translation
that translates by an integer multiple of device units, then it has no effect on
the rendering other than placement of the figure drawn on the display device.)

<P>
Roughly speaking, a pixel is affected by drawing a shape only when it is inside
the shape (we will define what we mean by ``inside'' in a moment).  Since pixels
are little squares and the abstract points have no size, for most shapes there
will be many pixels that lie only partially inside the shape.  Therefore, it is
important to describe the conventions used by CLIM as to which pixels should be
affected when drawing a shape, so that the proper interface to the per-platform
rendering engine can be constructed.  (It is worth noting that on devices that
support color or grayscale, the rendering engine may attempt to draw a pixel
that is partially inside the shape darker or lighter, depending on how much of
it is inside the shape.  This is called <I> anti-aliasing</I><A NAME="13097"></A>.)  The conventions
used by CLIM is the same as the conventions used by X11:

<P>

<UL>
<LI>A pixel is a addressed by its upper-left corner.

<P>
 </LI>
<LI>A pixel is considered to be <I> inside</I><A NAME="13099"></A> a shape, and hence affected
by the rendering of that shape, if the center of the pixel is inside the shape.
If the center of the pixel lies exactly on the boundary of the shape, it is
considered to be inside if the inside of the shape is immediately to the right
(increasing 1#1 direction on the display device) of the center point of the
pixel.  If the center of the pixel lies exactly on a horizontal boundary, it is
considered to be inside if the inside of the shape is immediately below
(increasing 2#2 direction on the display device) the center point of the pixel.

<P>
 </LI>
<LI>An unfilled shape is drawn by taking the filled shape consisting of those
points that are within 1/2 the line thickness from the outline curve (using a
normal distance function, that is, the length of the line drawn at right angles
to the tangent to the outline curve at the nearest point), and applying the
second rule, above.</LI>
</UL>

<P>
It is important to note that these rules imply that the decision point used for
insideness checking is offset from the point used for addressing the pixel by
half a device unit in both the 1#1 and 2#2 directions.  It is worth considering
the motivations for these conventions.

<P>
When two shapes share a common edge, it is important that only one of the shapes
own any pixel.  The two triangles in Figure&nbsp;<A HREF="node111.html#two-triangles">12.1</A> illustrate this.
The pixels along the diagonal belong to the lower figure.  When the decision
point of the pixel (its center) lies to one side of the line or the other, there
is no issue.  When the boundary passes through a decision point, which side the
inside of the figure is on is used to decide.  These are the triangles that CLIM
implementations should attempt to draw in this case.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="two-triangles"></A><A NAME="13067"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
Pixel assignment with boundary on decision points.</CAPTION>
<TR><TD>49#49</TD></TR>
</TABLE>
</DIV><P></P>

<P>
The reason for choosing the decision point half a pixel offset from the address
point is to reduce the number of common figures (such as rectilinear lines and
rectangles with integral coordinates) that invoke the boundary condition rule.
This usually leads to more symmetrical results.  For instance, in
Figure&nbsp;<A HREF="node111.html#corner-circle">12.2</A>, we see a circle drawn when the decision point is the
same as the address point.  The four lighter points are indeterminate: it is not
clear whether they are inside or outside the shape.  Since we want to have each
boundary case determined according to which side has the figure on it, and since
we must apply the same rule uniformly for all figures, we have no choice but to
pick only two of the four points, leading to an undesirable lopsided figure.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="corner-circle"></A><A NAME="13069"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
Choosing any two of the shaded pixels causes asymmetry.</CAPTION>
<TR><TD>50#50</TD></TR>
</TABLE>
</DIV><P></P>

<P>
If we had instead chosen to take all four boundary points, we would have a nice
symmetrical figure.  However, since this figure is symmetrical about a whole
pixel, it is one pixel wider than it ought to be.  The problem with this can be
seen clearly in Figure&nbsp;<A HREF="node111.html#inscribed-circle">12.3</A> if we attempt to draw a rectangle
and circle overlaid with the following code:

<P>
 
<PRE>

(defun draw-test (sheet radius)
  (draw-circle* sheet 0 0 radius :ink +foreground-ink+)
  (draw-rectangle* sheet (- radius) (- radius) (+ radius) (+ radius)
                   :ink +flipping-ink+))
</PRE>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="inscribed-circle"></A><A NAME="13071"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
Two forms of a circle inscribed in a rectangle.</CAPTION>
<TR><TD>51#51</TD></TR>
</TABLE>
</DIV><P></P>

<P>
It is for this reason that we choose to have the decision point at the center of
the pixel.  This draws circles that look like the one in
Figure&nbsp;<A HREF="node111.html#correct-circle">12.4</A>.  It is this shape that CLIM implementations should
attempt to draw.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="correct-circle"></A><A NAME="13073"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
An aesthetically pleasing circle.</CAPTION>
<TR><TD>52#52</TD></TR>
</TABLE>
</DIV><P></P>

<P>
A consequence of these rendering conventions is that, when the start or end
coordinate (minus 1/2 the line thickness, if the shape is a path) is not an
integer, then rendering is not symmetric under reflection transformations.  Thus
to correctly and portably draw an outline of thickness 1 around a (rectilinear)
rectangular area with integral coordinates, the outline path must have
half-integral coordinates.  Drawing rectilinear areas whose boundaries are not
on pixel boundaries cannot be guaranteed to be portable.  Another way to say the
same thing is that the ``control points'' for a rectangular area are at the
corners, while the control points for a rectilinear path are in the center of
the path, not at the corners.  Therefore, in order for a path and an area to
abut seamlessly, the coordinates of the path must be offset from the coordinates
of the area by half the path's thickness.

<P>
<BR><HR>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html2276"
 HREF="node112.html">Permissible Alternatives During Rendering</A>
</UL>
<!--End of Table of Child-Links-->
<HR>
<!--Navigation Panel-->
<A NAME="tex2html2274"
 HREF="node112.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/icons/next_motif.gif"></A> 
<A NAME="tex2html2270"
 HREF="node105.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/icons/up_motif.gif"></A> 
<A NAME="tex2html2264"
 HREF="node110.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/icons/previous_motif.gif"></A> 
<A NAME="tex2html2272"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="/icons/contents_motif.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html2275"
 HREF="node112.html">Permissible Alternatives During Rendering</A>
<B> Up:</B> <A NAME="tex2html2271"
 HREF="node105.html">Graphics</A>
<B> Previous:</B> <A NAME="tex2html2265"
 HREF="node110.html">Drawing is Approximate</A>
 &nbsp <B>  <A NAME="tex2html2273"
 HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>&</I>
<BR><I>2001-06-12</I>
</ADDRESS>
</BODY>
</HTML>
