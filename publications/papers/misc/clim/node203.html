<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 99.1 release (March 30, 1999)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Pointer Tracking</TITLE>
<META NAME="description" CONTENT="Pointer Tracking">
<META NAME="keywords" CONTENT="clim">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.1 release">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="clim.css">

<LINK REL="next" HREF="node204.html">
<LINK REL="previous" HREF="node202.html">
<LINK REL="up" HREF="node196.html">
<LINK REL="next" HREF="node204.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html3532"
 HREF="node204.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/icons/next_motif.gif"></A> 
<A NAME="tex2html3528"
 HREF="node196.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/icons/up_motif.gif"></A> 
<A NAME="tex2html3522"
 HREF="node202.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/icons/previous_motif.gif"></A> 
<A NAME="tex2html3530"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="/icons/contents_motif.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html3533"
 HREF="node204.html">Gesture Preprocessing</A>
<B> Up:</B> <A NAME="tex2html3529"
 HREF="node196.html">Extended Stream Input</A>
<B> Previous:</B> <A NAME="tex2html3523"
 HREF="node202.html">The Pointer Protocol</A>
 &nbsp <B>  <A NAME="tex2html3531"
 HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION07150000000000000000">
Pointer Tracking</A>
</H1>

<P>
tracking-pointer (sheet <TT> &amp;key </TT>pointer multiple-windows
                                          transformp context-type)
                              <TT> &amp;body </TT>body

<P>
Provides a general means for running code while following the position of a
pointing device, and monitoring for other input events.  The programmer supplies
code (the clauses in <I> body</I>) to be run upon the occurrence of any of the
following types of events:

<P>

<UL>
<LI>Motion of the pointer

<P>
 </LI>
<LI>Motion of the pointer over a presentation

<P>
 </LI>
<LI>Clicking or releasing a pointer button

<P>
 </LI>
<LI>Clicking of a pointer button on a presentation

<P>
 </LI>
<LI>Keyboard event (typing a character)</LI>
</UL>

<P>
The <I> sheet</I> argument is not evaluated, and must be a symbol that is bound to
an input sheet or stream.  If <I> sheet</I> is t, *standard-output* is
used.  <I> body</I> may have zero or more declarations as its first forms.

<P>
The <I> pointer</I> argument specifies a pointer to track.  It defaults to
the primary pointer for the sheet, (stream-primary-pointer <I> sheet</I>).

<P>
When the boolean <I> multiple-window</I> is <I> true</I>, then the pointer will be
tracked across multiple windows, otherwise is will be tracked only in the window
corresponding to <I> sheet</I>.

<P>
When the boolean <I> transformp</I> is <I> true</I>, then the coordinates supplied
to the :pointer-motion clause will be in the ``user'' coordinate system
rather than in stream coordinates, that is, the medium's transformation will be
applied to the coordinates.

<P>
 
<I> context-type</I> is used to specify the presentation type of presentations
that will be ``visible'' to the tracking code.  This is only meaningful when
<I> sheet</I> is an output recording stream. <I> context-type</I> defaults to
t, meaning that all presentations are visible.

<P>
The body of tracking-pointer consists of a list of clauses.  Each clause is
of the form

<BR>
<I> (clause-keyword arglist . clause-body)</I>

<BR>
and defines a local function to be run upon occurrence of each type of event.
The possible values for <I> clause-keyword</I> and the associated <I> arglist</I>
are:

<P>

<UL>
<LI>:presentation <I> (<TT> &amp;key </TT>presentation window x y)</I> 
<BR>
Defines a clause to run whenever the pointer moves over a presentation of the
desired type.  (See the keyword argument :context-type above for a
description of how to specify the desired type.)  In the clause,
<I> presentation</I> is bound to the presentation, <I> window</I> to the window in
which the motion occurred, and <I> x</I> and <I> y</I> to the coordinates of the
pointer.  (See the keyword argument :transformp above for a description of
the coordinate system in which <I> x</I> and <I> y</I> are expressed.)

<P>
 </LI>
<LI>:pointer-motion <I> (<TT> &amp;key </TT>window x y)</I> 
<BR>
Defines a clause to run whenever the pointer moves.  In the clause, <I> window</I>
is bound to the window in which the motion occurred, and <I> x</I> and <I> y</I> to
the coordinates of the pointer. (See the keyword argument :transformp below
for a description of the coordinate system in which <I> x</I> and <I> y</I> are
expressed.)

<P>
When both :presentation and :pointer-motion clauses are provided, the
two clauses are mutually exclusive.  The :presentation clause will run if
applicable, otherwise the :pointer-motion clause will run.

<P>
 </LI>
<LI>:keyboard <I> (<TT> &amp;key </TT>gesture)</I> 
<BR>
Defines a clause to run whenever a character is typed on the keyboard.  In the
clause, <I> gesture</I> is bound to the keyboard gesture corresponding to the
character typed.

<P>
 </LI>
<LI>:presentation-button-press <I> (<TT> &amp;key </TT>presentation event x y)</I> 
<BR>
Defines a clause to run whenever the pointer button is pressed while the pointer
is over a presentation of the desired type. (See the keyword argument
:context-type below for a description of how to specify the desired type.)
In the clause, <I> presentation</I> is bound to the presentation, and <I> event</I>
to the pointer button press event.  (The window and the stream coordinates of
the pointer are part of <I> event</I>.)

<P>
 
<I> x</I> and <I> y</I> are the transformed 1#1 and 2#2 positions of the pointer.
These will be different from pointer-event-x and pointer-event-y if
the user transformation is not the identity transformation.

<P>
 </LI>
<LI>:pointer-button-press <I> (<TT> &amp;key </TT>event x y)</I> 
<BR>
Defines a clause to run whenever a pointer button is pressed. In the clause,
<I> event</I> is bound to the pointer button press event. (The window and the
coordinates of the pointer are part of <I> event</I>.)

<P>
When both :presentation-button-press and :pointer-button-press
clauses are provided, the two clauses are mutually exclusive. The
:presentation-button-press clause will run if applicable, otherwise the
:pointer-button-press clause will run.

<P>
 
<I> x</I> and <I> y</I> are the transformed 1#1 and 2#2 positions of the pointer.
These will be different from pointer-event-x and pointer-event-y if
the user transformation is not the identity transformation.

<P>
 </LI>
<LI>:pointer-button-release <I> (<TT> &amp;key </TT>event x y)</I> 
<BR>
Defines a clause to run whenever a pointer button is released. In the clause,
<I> event</I> is bound to the pointer button release event. (The window and the
coordinates of the pointer are part of <I> event</I>.)

<P>
 
<I> x</I> and <I> y</I> are the transformed 1#1 and 2#2 positions of the pointer.
These will be different from pointer-event-x and pointer-event-y if
the user transformation is not the identity transformation.</LI>
</UL>

<P>
drag-output-record stream output-record
                                  <TT> &amp;key </TT>repaint erase feedback finish-on-release

<P>
Enters an interaction mode in which the user moves the pointer and
<I> output-record</I> ``follows'' the pointer by being dragged on the <I> output
recording stream</I> <I> stream</I>.  By default, the dragging is accomplished by
erasing the output record from its previous position and redrawing at the new
position.  <I> output-record</I> remains in the output history of <I> stream</I> at
its final position.

<P>
The returned values are the final 1#1 and 2#2 position of the pointer.

<P>
The boolean <I> repaint</I> allows the programmer to control the appearance of
windows as the pointer is dragged.  If <I> repaint</I> is <I> true</I> (the
default), displayed contents of windows are not disturbed as the output record
is dragged over them (that is, those regions of the screen are repainted).  If
it is <I> false</I>, then no repainting is done as the output record is dragged.

<P>
 
<I> erase</I> allows the programmer to identify a function that will be called to
erase the output record as it is dragged.  It must be a function of two
arguments, the output record to erase and the stream; it has dynamic extent.
The default is erase-output-record.

<P>
 
<I> feedback</I> allows the programmer to identify a ``feedback'' function.
<I> feedback</I> must be a is a function of seven arguments: the output record,
the stream, the initial 1#1 and 2#2 position of the pointer, the current 1#1 and
2#2 position of the pointer, and a drawing argument (either :erase or
:draw).  It has dynamic extent.  The default is nil, meaning that the
feedback behavior will be for the output record to track the pointer.  (The
<I> feedback</I> argument is used when the programmer desires more complex
feedback behavior, such as drawing a ``rubber band'' line as the user moves the
mouse.)  Note that if <I> feedback</I> is supplied, <I> erase</I> is ignored.

<P>
If the boolean <I> finish-on-release</I> is <I> false</I> (the default),
drag-output-record is exited when the user presses a pointer button.  When
it is <I> true</I>, drag-output-record is exited when the user releases the
pointer button currently being held down.

<P>
dragging-output (<TT> &amp;optional </TT>stream <TT> &amp;key </TT>repaint finish-on-release)
                             <TT> &amp;body </TT>body

<P>
Evaluates <I> body</I> inside of with-output-to-output-record to produce an
output record for the stream <I> stream</I>, and then invokes
drag-output-record on the record in order to drag the output.  The output
record is not inserted into <I> stream</I>'s output history.

<P>
The returned values are the final 1#1 and 2#2 position of the pointer.

<P>
The <I> stream</I> argument is not evaluated, and must be a symbol that is bound
to an <I> output recording stream</I> stream.  If <I> stream</I> is t (the
default), *standard-output* is used.  <I> body</I> may have zero or more
declarations as its first forms.

<P>
 
<I> repaint</I> and <I> finish-on-release</I> are as for drag-output-record.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html3532"
 HREF="node204.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/icons/next_motif.gif"></A> 
<A NAME="tex2html3528"
 HREF="node196.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/icons/up_motif.gif"></A> 
<A NAME="tex2html3522"
 HREF="node202.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/icons/previous_motif.gif"></A> 
<A NAME="tex2html3530"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="/icons/contents_motif.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html3533"
 HREF="node204.html">Gesture Preprocessing</A>
<B> Up:</B> <A NAME="tex2html3529"
 HREF="node196.html">Extended Stream Input</A>
<B> Previous:</B> <A NAME="tex2html3523"
 HREF="node202.html">The Pointer Protocol</A>
 &nbsp <B>  <A NAME="tex2html3531"
 HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>&</I>
<BR><I>2001-06-12</I>
</ADDRESS>
</BODY>
</HTML>
