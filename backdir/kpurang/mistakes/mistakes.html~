<HTML>
<HEAD>
<TITLE>Mistakes</title>
</head>

<!body bgcolor="#ffffee" text="#000000" link="#ff0000" vlink="0000ff">
<!body bgcolor="#eeeeee" text="#000000" link="#ff0000" vlink="0000ff">

<h2> Detecting, reasoning with and repairing mistakes</h2>



{\bf Mistakes are unavoidable} Mistakes are pervasive in software
agents and in software systems in general.  Consider an agent
operating in some non-trivial domain. It's knowledge of the domain is
likely to be incomplete, uncertain and the domain will be constantly
changing through its actions or those of other agents. This, together
with the fact that any agent has limited resources means that it is
unavoidable that the agent represent a fact that is not true. This
mistake can then spread to other beliefs of the agent, to its
intentions and to its actions.  Similar events can happen in any
software system when its inputs are not as expected or components of
the system fail.  The consequences of mistakes can range from
annoyances to catastrophic failures. This lack of appropriate response
to mistakes is also part of the general perception that software
systems are rigid, inflexible and not robust. 

Part of the solution to these problems may be better specification of
the domain with a response for each state that may occur, faster
computers or better testing but that is not likely to be adequate. The
incompleteness and uncertainty of knowledge guarantee surprises and
having to have a specific response to each surprise, even those that
occur with very low probability may be prohibitively expensive. These
problems become much worse as the size and complexity of the system
increases.

{\bf A solution}
The solution is not to build all possible mistake handling strategies
into the system, but to enable the system to detect, reason about and
repair its own mistakes. The system can detect mistakes by observing
the environment, its own reasoning or by inference from other
mistakes. Mistaken beliefs (believing that P when not(P)) can lead to
mistaken intentions (committing to a plan that does not result in the
goal). Similarly, mistaken actions (actions that do not result in
their postconditions) can lead to a realization that the intention
that triggered this action was mistaken, and that some relevant belief
was mistaken too.

Because of the incompleteness and uncertainty of the knowledge, the
agent can never be sure that its beliefs are true. It can act as
though they are but then with further reasoning find that these
beliefs were mistaken. If some mistaken belief was used to form an
intention, that intention can then be withdrawn or other corrective
actions can be taken before there is any bad consequence in the
world. And if the plan has started to be executed, the agent can
reason about the best way to correct the situation. However, it may
turn out that the agent later finds that the belief that there was a
mistake was itself mistaken, so that the agent must now repair what it
previously thought to be repairs.

{\bf Capabilities needed} The capabilities required for a general
implementation of such an agent seem to be a basic ability to do
inference, a representation of the domain, a sense of past and
present, a model of its own reasoning processes and a record of its
past reasoning, intentions and actions.  These are quite extensive
capabilities and can generate problems and complexities of their
own. However, it is possible for systems with less than these very
general abilities to react to mistakes in a somewhat flexible
way. Another factor that leads to a tradeoff of flexibility and
efficiency is the representation used for mistakes. Explicitly
representing mistakes at the times that they occur seem to give the
agnet the ability to reason about them. But the agnet can still reason
to some extent about mistakes without these explicit representations.
There seems to be a range of capabilities and possible behaviors
for agents regarding the occurrence of mistakes.

{\bf Current work} Part of ongoing work is investigating the tradeoffs
between flexibility in handling mistakes and the complexity and
efficiency of the resulting system.

A few systems that handle mistakes along the lines described above
have been implemented. The implementations have been done in the
framework of active logic which provides the required capabilities. 

Two of the implementations handle a narrow class of mistakes in
presupposition processing and in implicature processing
respectively. The procedures to identify and react to mistakes are
specific to each of these applications and are not very
flexible. However, they detect and react to the mistakes efficiently.

A more general implementation of a system for dealing with mistakes is
a nonmonotonic reasoner. This allows some of the strategies to
identify and reason with mistakes to be declaratively stated in the
form of defaults and preferences among defaults. The same algorithms
can then used to deal with a wide range of domains. This gives the
system more flexibility than the previous ones. However, the mistakes
are not explicitly represented in this system which limits the sorts
of mistakes it can handle.

This system is being extended to use a more explicit representation of
mistakes and the range of mistakes it is able to handle is expected
to grow.







\end{document}




</html>