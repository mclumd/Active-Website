
% file mistake2.pl
% requires mistake_help.pl 

% Feb 01
% kpurang

/***************************************************

  Differences from mistake.pl:
    1. We do not use the 'true' predicates. Use introspection instead.
    2. We do not have to specify when to check for a mistake. Once we
    have a contra, we check for mistakes ofr all times from 1 to the time 
    we get the contra. Might be a bit expensive. Need to have this
    behavior controlled by user.

  mistake(P, T) means that at time T, the system could have derived that
  not(P) if it could do arbitrary amounts of computation in a step.

  Detecting mistakes.

  If we believe P at time t1 and not(P) at time t2, then we can ask whether 
  we were mistaken in the belief at t1.

  We are mistaken if we find that not(P) was true at t1 but we believed P,
  and not(P) is true now.

  not(P) was true at t1 if the premises of the derivation of not(P) 
  were all true at t1.

  truth of formulas is taken to be given. So that true(P, t) says that
  formula P is true at time t.

  There are other ways to do this though.

  We assume that we now believe not(P) and we did believe P earlier if
  we are asked whether P was mistaken at the earlier time. To relax this.
  just add the appropriate conjunctions.


  strategy:
  0. find_mistake(P, T) asserted:
  1. if not(P) in kb now, and P in kb at T, and name of P = NP
     and contra(NP, X, S) or contra(X, NP, S), get derivation of
     X = DX. Check for each of the leaves of DX whether it is true at T.
     IF so, mistake, else not.

  Derivations lok like that:

  deriv(25,[[deriv(penguins_dont_fly,[]),
             deriv(22,[[deriv(swim_bird_penguin,[]),
                        deriv(swims_tweety,[]),
                        deriv(bird_tweety,[])],
                       [deriv(swim_bird_penguin,[]),
                        deriv(bird_tweety,[]),
                        deriv(swims_tweety,[])]])]]) 

   We have a prolog program to extract the leaves
  
***************************************************/

% Tweety is a bird that swims. Birds fly and penguins don't. Birds tha
% swim are penguins.

%named(bird(tweety), bird_tweety).
%named(swims(tweety), swims_tweety).
%named(fif(and(bird(X), swims(X)), conclusion(penguin(X))), swim_bird_penguin).
named(fif(bird(X), conclusion(flies(X))), birds_fly).
named(fif(penguin(X), conclusion(not(flies(X)))), penguins_dont_fly).



if(and(bird(X), breeds_in(X, antarctic)), 
   (or(penguin(X), or(petrel(X), skua(X))))).
if(petrel(X), not(dives_to(X, 150))).
if(skua(X), not(dives_to(X, 150))).

bird(tweety).
breeds_in(tweety, antarctic).
dives_to(tweety, 150).



% The default that penguins don't fly is preferred to that about birds
% flying.

prefer(penguins_dont_fly, birds_fly).

% The above named formulas are taken to be true at all times.

% true(bird_tweety, T).
% true(swims_tweety, T).
% true(swim_bird_penguin, T).
% true(penguin_tweety, T).
% true(birds_fly, T).
% true(penguins_dont_fly, T).


% This asserts in the database the leaves of the derivation of the
% formula we now believe (not quite).

fif(and(find_mistake(P, Time),
	and(distrusted(N1, T1),
	    and(eval_bound(name_to_formula(N1, [P]), [N1, P]),
		and(contra(N1, N2, TT),
		    and(eval_bound(name_to_derivation(N2, Deriv), [N2]),
			eval_bound(get_derivation_leaf(Deriv, Leaf), 
				   [Deriv])))))),
    conclusion(check_deriv(Leaf, P, Time))).

fif(and(find_mistake(P, Time),
	and(distrusted(N1, T1),
	    and(eval_bound(name_to_formula(N1, P), [N1, P]),
		and(contra(N2, N1, TT),
		    and(eval_bound(name_to_derivation(N2, Deriv), [N2]),
			eval_bound(get_derivation_leaf(Deriv, Leaf), 
				   [Deriv])))))),
    conclusion(check_deriv(Leaf, P, Time))).

% Here we check the leaves of the derivations for truth at the time we
% are interested in.

fif(check_deriv([], P, Time), conclusion(mistake(P, Time))).

fif(and(check_deriv([X|R], P, Time),
	and(eval_bound(pos_int(P, Time), [P, Time]),
	    and(eval_bound(name_to_formula(X, XF), [X]),
		eval_bound(pos_int(XF, Time), [XF])))),
    conclusion(check_deriv(R, P, Time))).


% The contradiction resolution axioms prefer a formula that is derived from
% a preferred default.

% if there is a contradiction, find the parents

if(and(contra(X, Y, Z), eval_bound(name_to_parents(X, PX), [X])),
   parentsof(X, PX)).
if(and(contra(Y, X, Z), eval_bound(name_to_parents(X, PX), [X])),
   parentsof(X, PX)).

% find which contradictand has a preferred parent, reinstate that one

fif(and(parentsof(C1, P1),
       and(parentsof(C2, P2),
	   and(eval_bound(contains(P1, PP1), [P1, PP1]),
	       and(eval_bound(contains(P2, PP2), [P2, PP2]),
		   prefer(PP1, PP2))))),
   conclusion(resolved_contra(C1, C2))).

fif(and(parentsof(C1, P1),
       and(parentsof(C2, P2),
	   and(eval_bound(contains(P1, PP1), [P1, PP1]),
	       and(eval_bound(contains(P2, PP2), [P2, PP2]),
		   prefer(PP2, PP1))))),
   conclusion(resolved_contra(C2, C1))).

fif(resolved_contra(X, Y), conclusion(reinstate(X))).

fif(and(resolved_contra(X, Y), 
	eval_bound(name_to_formula(Y, YF), [Y])),
    conclusion(find_mistake(YF, Z))).
