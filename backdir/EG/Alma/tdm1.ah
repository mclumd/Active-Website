%dialog manager action handling scripts
%by Carl Andersen and Darsana Purushothaman 1998-1999

:- use_module('gram4.pl').
:- ensure_loaded(library(ctypes)).
:- ensure_loaded(library(basics)).
:- ensure_loaded(library(strings)).
:- ensure_loaded(library(maplist)).
:- dynamic contexts/2.
:- dynamic lobj/2.
:- dynamic from/2.
:- dynamic to/2.
:- dynamic 'at-loc'/2.

/******************************
actions to be called by ALMA
*************************/

ah_test :- 
print('doing ah_test'),nl,
gram4:write_line(user_output,"testing DM..."),nl,
call(dm_init),!,
getmsg(ID),
print('test message ID: '),
print(ID),nl,
convert_keyvals1(ID), !,
convert_keyvals2(ID), !,
oassert(newmsg(ID)),
oassert(curr_utt(ID)),
oassert(contexts(ID,[plan1])),!,
print('finished ah_test'),nl.

ah_init :- !,
call(dm_init),
sendmsg1(['REGISTER :RECEIVER IM :NAME DM']),
sendmsg1(['TELL :RECEIVER IM :CONTENT (READY)']),
sendmsg1(['REQUEST :SENDER DM :RECEIVER IM :CONTENT (LISTEN PARSER)']).

%gather_asserts(ID,AList) :-
%A is kqml_kv(ID,[Keyword,Expr]),
%B is kqml_head(ID,Head),
%write(A),
%write(B).

ah_makecall(Type,Args) :-
Call =.. [Type|Args],
af(call(Act1,Call)).

ah_preprocess_msg(ID,Asserts) :-
passertall(Asserts),
convert_keyvals1(ID), !,
convert_keyvals2(ID), !,
(kqml_kv(ID,[sender,Sender]),
 oassert(sender(ID,Sender)); true),
(kqml_kv(ID,[re,Re]),
 oassert(ireq(re(ID,Re),ID)); true),
(kqml_kv(ID,['in-reply-to',RW]),
 oassert('in-reply-to'(ID,RW)); true),
kqml_to_msg(ID,Msg),
oassert(msgname(ID,Msg)),
gathered_asserts(Asserts1),
af(new_message_kv(ID,Asserts1)),
pretractall(Asserts).

ah_translate_parse(ID,Asserts) :-
passertall(Asserts),
oassert(curr_utt(ID)),
oassert(ireq(contexts(ID,[plan1]),ID)),!,
translate_parser_input(ID),
pretractall(Asserts).
%  alassert_translation(ID),

ah_askquestion(ID,Type,ID1,Asserts,Asserts1) :-
passertall(Asserts),
makequestion(ID,Type,ID1),
sendmsg(ID1),
pretractall(Asserts),
gathered_asserts(Asserts1).

ah_process_ynq(ID,ID2,ID3) :-
makepsbindings(ID2),
makeoutput(ID,'sa-yn-question',if,ID3),
sendmsg(ID3).

ah_process_whq(ID,Type,ID2,ID3) :-
makepsbindings(ID2),
makeoutput(ID,'sa-wh-question',Type,ID3),
sendmsg(ID3).

ah_translate_queryans(ID,ID2,Asserts) :-
passertall(Asserts),
makepsbindings(ID,ID2),
ah_confirmbound(ID),
pretractall(Asserts).

ah_confirmbound(ID) :-
ireq(lf(Sem,LF),ID),
recsubst(ID,dreq,false,LF,LF1),
(getvars(LF1,[])).

ah_translate_plan(ID,ID2,Asserts) :-
passertall(Asserts),
translate_plan(ID,ID2),
pretractall(Asserts).

ah_reqnewsubplan(ID,ID2,ID4,Asserts,Asserts1) :-
passertall(Asserts),
makenewsubplanreq(ID,ID4),
sendmsg(ID4),
gathered_asserts(Asserts1),
pretractall(Asserts).

ah_requpdateplan(ID,ID2,ID4,Asserts) :-
passertall(Asserts),
makeupdateplanreq(ID,ID4),
sendmsg(ID4),
pretractall(Asserts).

ah_confirmsuccess(ID,ID2,Asserts) :-
passertall(Asserts),
kqml_kv(ID2,['content',ID3]),
kqml_expr(ID3,[_,_,ID4|_]),
kqml_expr(ID4,[_,success]),
pretractall(Asserts).

ah_outmgrconfirm(ID,Asserts) :-
passertall(Asserts),
makeoutput(ID,'sa-request','new-subplan',ID30),
sendmsg(ID30),
pretractall(Asserts).

/* procedure for adding assertions to ALMA 
currently unnecessary - just change oassert instead

alassert_translation(ID) :-
alassert_translation1(ID,Forms),
alassert_forms(Forms).

alassert_translation1(ID,Forms) :-
findall(T,(T = type(ID,_),T),Ts)
findall(F,(F = focus(ID,_),F),Fs)
findall(O,(O = object(ID,_),O),Os)
findall(C,(C = constraint(ID,_),C),Cs)
findall(A,(O = object(ID,Obj),
	   (A = class(Obj,_);A = lex(Ob,_);A = sort-of(Obj,_);A = status(Obj,_);A = at-loc(Obj,_)),As)),
findall(P,(P = path(ID,_)),Ps),
findall(P,(P = path(ID,Path),
	   (PA = from(Path,_);to(Path,_))),PAs),

alassert_forms([F|Forms]) :-
af(F),
assert_forms(Forms).
*/

ah_makewait(Act,[Assert|Asserts],W) :-
af(Assert),
ah_makewait(Act,[Assert|Asserts],W).
ah_makewait(Act,[],[Wait|Waits]) :-
af(if(Wait,ah_makewait(Act,[],Waits))).
ah_makewait(Act,[],[]) :-
af(done(Act)).

/*****************************
generic code to send and wait for messages
****************************/

%Msg is the prolog list structure made from the incoming message
getmsg(ID) :-
repeat,
gram4:get_a_line(user_input,[],Out),
parse_kqml_perf(Out,ID),
convert_keyvals1(ID), !,
convert_keyvals2(ID), !.

%get a message from Sender
%ignore any messages that arrive in the meantime
getmsg(Sender,ID) :-
repeat,
getmsg(ID1),
kqml_head(ID1,_),
(kqml_head(ID1,quit) -> raise_exception(quit);true),
(kqml_head(ID1,restart) -> raise_exception(restart);true),
\+ kqml_head(ID1,cd),
kqml_kv(ID1,[sender,Sender1]),
kqml_kv(ID1,[receiver,Receiver1]),
((Sender1 == Sender,Receiver1 == dm) -> ID = ID1).

%send a Msg to standard output
sendmsg(ID) :-
is_kqml_var(ID),
unparse_kqml_perf(ID,Msg),
kqml_to_msg(ID,Name),
oassert(msgname(ID,Name)),
gram4:write_line(user_output,Msg),nl.

%send a nested list Msg to standard output
sendmsg1(Msg) :-
gram4:pparser(Msg,Msg1),
parse_kqml_perf(Msg1,ID),
kqml_retract(ID),
gram4:write_line(user_output,Msg1),nl.

%send an error Msg to standard output
%Sender is the last module to send dm a message
%ID2 is that message
senderrmsg(ID,Sender,ID1) :-
assert_head(ID9,express),
oassert(kqml_kv(ID9,[':speech-act',inform])),
oassert(kqml_kv(ID9,[':sender',dm])),
oassert(kqml_kv(ID9,[':receiver',outmgr])),
assert_expr(ID2,[error,Sender,ID1]),
oassert(kqml_kv(ID9,[':content',ID2])),
assert_msg(ID9,dm,Sender,ID1,ID9),
sendmsg(ID9).

/******************
code to translate parser and ps messages
******************/

translate_parser_input(ID) :-
kqml_kv(ID,[content,ContentID]),
kqml_kv(ContentID,[noise,NoiseID]),
kqml_expr(NoiseID,[alma,reset]),
oassert(reset_alma(ID)).

translate_parser_input(ID) :-
kqml_kv(ID,[content,ContentID]),
kqml_head(ContentID,Type),
kqml_kv(ContentID,[focus,Focus]),
oassert(ireq(type(ID,Type),ID)),!,
oassert(ireq(focus(ID,Focus),ID)),!,
kqml_kv(ContentID,[objects,ObjectListID]),
kqml_expr(ObjectListID,ObjectIDList),
makeobjects(ID,ObjectIDList),
kqml_kv(ContentID,[paths,PathListID]),
(is_kqml_var(PathListID) -> 
 (kqml_expr(PathListID,PathIDList),
  makepaths(ID,PathIDList));true),
kqml_kv(ContentID,[semantics,SemID]),
makesem(ID,SemID),
makebindings(ID),
makePSConstraints(ID).

makeobjects(ID,[ObjID|ObjectIDList]) :-
makeobject(ID,ObjID),!,
makeobjects(ID,ObjectIDList).
makeobjects(ID,[]).

makeobject(ID,ObjID) :-
kqml_head(ObjID,description),!,
kqml_kv(ObjID,[var,Var]),!,
oassert(ireq(obj(ID,Var),ID)),!,
findall([Att,Val],makeobject1(ID,ObjID, Var, [Att,Val]),AttVals).

makeobject1(ID,ObjID, Var,[Att,Val]) :-
kqml_kv(ObjID,[Att,Val]),
makeobjatts(ID,Var,[Att,Val]).
makeobject1(_,_,[]).

%assert constraints found in objects
makeobjatts(ID,Var,[Att, Val]) :- 
Att = class,!,
is_kqml_var(Val),!,
kqml_expr(Val,[pred,_,ID1]),
kqml_expr(ID1,AVPair),
makeobjatts(ID,Var,AVPair).
makeobjatts(ID,Var,[Att, Val]) :- 
Att = class,!,
oassert(ireq(class(Var,Val),ID)),!,
oassert(ireq(constraint(ID,[class,Var,Val]),ID)).
makeobjatts(ID,Var,[Att, Val]) :- 
Att = class,!,
oassert(ireq(class(Var,Val),ID)),!,
oassert(ireq(constraint(ID,[class,Var,Val]),ID)).
makeobjatts(ID,Var,[Att,Val]) :- 
Att = lex,!,
oassert(ireq(lex(Var,Val),ID)),!,
oassert(ireq(constraint(ID,[lex,Var,Val]),ID)).
makeobjatts(ID,Var,[Att,Val]) :- 
%this conflicts with a defined prolog pred
Att = sort,!,
oassert(ireq('sort-of'(Var,Val),ID)),!,
oassert(ireq(constraint(ID,['sort-of',Var,Val]),ID)).
makeobjatts(ID,Var,[Att,Val]) :- 
Att = status,!,
oassert(ireq(status(Var,Val),ID)),!,
oassert(ireq(constraint(ID,['status',Var,Val]),ID)).
makeobjatts(ID,Var,[constraint,ConsID]) :- 
kqml_expr(ConsID,[Att,Var,Val]),!,
%could not have a ! cut here
((Att == 'assoc-with'; Att == 'at-loc') -> 
 (oassert(ireq('at-loc'(Var,Val),ID)),
  oassert(ireq(constraint(ID,['at-loc',Var,Val]),ID)));
true).
makeobjatts(ID,Var,[Att,Val]).

%make paths; hope this treatment of nil works ok.
makepaths(ID,nil).
makepaths(ID,[PathID|PathIDList]) :-
kqml_head(PathID,path),
kqml_kv(PathID,[var,Path]),
oassert(ireq(path(ID,Path),ID)),!,
kqml_kv(PathID,[constraint,ConstraintID]),
makepathconstraintfrom(ID,Path,Constraint),
makepathconstraintto(ID,Path,Constraint),
makepaths(PathIDList).
makepaths([]).

%some paths do not have this info, so always succeed
%2-1-99 but will these paths function ok?
makepathconstraintfrom(ID,Path,ConstraintID) :-
kqml_expr(ConstraintID,[from,_,From]),
oassert(ireq(from(Path,From),ID)),!,
oassert(ireq(constraint(ID,[from,Path,From]),ID)).
makepathconstraintfrom(_,_,_).
makepathconstraintto(ID,Path,ConstraintID) :-
kqml_expr(ConstraintID,[to,_,To]),
oassert(ireq(to(Path,To),ID)),!,
oassert(ireq(constraint(ID,[to,Path,To]),ID)).
makepathconstraintto(_,_,_).

makesem(ID,SemID) :-
kqml_head(SemID,prop),
kqml_kv(SemID,[var,Sem]),
oassert(ireq(sem(ID,Sem),ID)),!,
kqml_kv(SemID,[constraint,ConstraintID]),
(kqml_expr(ConstraintID,[and|ConstraintIDList]);
 ConstraintIDList = [ConstraintID]),
makesemconst(ID,Sem,ConstraintIDList),!,
makesemclass(ID,SemID,Sem),
makesemlf(ID,Sem).

makesemconst(ID,Sem,[ConstraintID|ConstraintIDList]) :-
kqml_expr(ConstraintID,[Att,_,Val]),
((Att = lsubj -> 
 oassert(ireq(lsubj(Sem,Val),ID)));
(Att = lobj -> 
 oassert(ireq(lobj(Sem,Val),ID)));
(Att = lcomp -> 
 oassert(ireq(lcomp(Sem,Val),ID)));
 true),
makesemconst(ID,Sem,ConstraintIDList).
makesemconst(ID,Sem,[]).

makesemclass(ID,SemID,Sem) :-
kqml_kv(SemID,[class,SemClassExpr]),
is_kqml_var(SemClassExpr),
kqml_expr(SemClassExpr,[be,'at-loc']),
SemClass = beatloc,
ireq(lsubj(Sem,Lsubj),ID),
ireq(lobj(Sem,Lobj),ID),
oassert(ireq('at-loc'(Lsubj,Lobj),ID)),
oassert(ireq(constraint(ID,['at-loc',Lsubj,Lobj]),ID)),
oassert(ireq(class(Sem,SemClass),ID)).
makesemclass(ID,SemID,Sem) :-
kqml_kv(SemID,[class,SemClass]),
oassert(ireq(class(Sem,SemClass),ID)).

makesemlf(ID,Sem) :-
ireq(class(Sem,beatloc),ID),
ireq(lsubj(Sem,Lsubj),ID),
ireq(lobj(Sem,Lobj),ID),
oassert(ireq(lf(Sem,['at-loc',Lsubj,Lobj]),ID)).
makesemlf(ID,Sem) :-
ireq(class(Sem,exists),ID),
ireq(lsubj(Sem,Lsubj),ID),
ireq(constraint(ID,Constraint),ID),
Constraint = ['at-loc',Lsubj,_],
oassert(ireq(lf(Sem,Constraint),ID)).
makesemlf(ID,Sem) :-
ireq(class(Sem,move),ID),
ireq(path(ID,Path),ID),
ireq(to(Path,To),ID),
ireq(lsubj(Sem,Lsubj),ID),
ireq(lobj(Sem,Lobj),ID),
oassert(ireq(lf(Sem,[move,Lobj,To]),ID)).

%code to translate ps messages about plans

translate_plan(ID,ID2) :-
kqml_kv(ID2,['content', ID3]),
kqml_kv(ID3,['result', ID4]),
kqml_head(ID4,'new-subplan'),
kqml_kv(ID4,['plan', ID6]),
kqml_expr(ID6,[PlanID,'goal',ID8,'agent',Agent,'actions',ID10]),
oassert(pact(plan(PlanID),ID)),
kqml_kv(ID4,['objects',ID7]),
oassert(pact(objects(ID7),ID)),
kqml_expr(ID8,[Type,GoalID|_]),
oassert(pact(goal(PlanID,GoalID),ID)),
oassert(pact(type(GoalID,Type),ID)),
kqml_kv(ID8,[agent,Agent]),
oassert(pact(agent(PlanID,Agent),ID)),
kqml_kv(ID8,[from,From]),
kqml_kv(ID8,[to,To]),
oassert(pact(from(GoalID,From),ID)),
oassert(pact(to(GoalID,To),ID)),
kqml_expr(ID10,ActionIDs),
translate_plan_actions(ID,ID2,ActionIDs),
kqml_kv(ID3,['ps-state', PSState]),
oassert(pact(ID,psstate(ID,PSState))).

%do we need explicit ordering info in the assertions or can we just use ActID?
translate_plan_actions(ID,ID2,[ActionID|ActionIDs]) :-
kqml_head(ActionID,Type),
kqml_head2(ActionID,Act),
kqml_kv(ActionID,[from,From]),
kqml_kv(ActionID,[to,To]),
kqml_kv(ActionID,[track,Track]),
oassert(pact(action(ID,ID2,Act),ID)),
oassert(pact(type(Act,Type),ID)),
oassert(pact(from(Act,From),ID)),
oassert(pact(to(Act,To),ID)),
oassert(pact(track(Act,track),ID)),
translate_plan_actions(ID,ID2,ActionIDs).

translate_plan_actions(ID,ID2,[]).



/**********************
code to make specific external msgs
***********************/

makequestion(ID,Type,ID1) :-
    (Type == if -> Type1 = 'ask-one';
    Type == one -> Type1 = 'ask-one';
    Type == all -> Type1 = 'ask-all';
    Type == planbind -> Type1 = 'find-plan-bindings'),
    makePSAspects(ID,PSAspects),
    convert_vars(PSAspects,PSAspects1),
    assert_expr(ID2,PSAspects1),
%    findall([A,B,C],dreq(psConstraint(A,B,C),D),ID),
 %   print(D),nl,
    findall(PSCID,(dreq(psConstraint(ID,Constraint,PSConstraint),ID),
		   convert_vars(PSConstraint,PSConstraint1),
		   assert_expr(PSCID,PSConstraint1)),PSCIDs),
    remove_dups(PSCIDs,PSCIDs1),
    assert_expr(ID3,[':and'|PSCIDs1]),
    ireq(contexts(ID,Contexts),ID),
    assert_expr(ID4,Contexts),
    (Type == planbind -> 
	 makePSPlanContent(ID,ireq,ID5);
    ID5 = []),
    assert_ps_msg(Type1,dm,ps,ID,ID1,ID2,ID3,ID4,ID5,ID1).

assert_ps_msg(Verb,Sender,Receiver,Re,RepWith,Aspect,Content,Contexts, PlanContent,ID1) :-
    assert_head(ID1,Verb),
    (Aspect = [] -> true; oassert(kqml_kv(ID1,[':aspect',Aspect]))),
    (Content = [] -> true; oassert(kqml_kv(ID1,[':content',Content]))),
    (Contexts = [] -> true; oassert(kqml_kv(ID1,[':context',Contexts]))),
    (PlanContent = [] -> true; oassert(kqml_kv(ID1,[':plan-content',PlanContent]))),
    oassert(kqml_kv(ID1,[':sender',Sender])),
    oassert(kqml_kv(ID1,[':receiver',Receiver])),
    kqml_to_msg(Re,Re1),
    oassert(kqml_kv(ID1,[':re',Re1])),
    kqml_to_msg(RepWith,RepWith1),
    oassert(kqml_kv(ID1,[':reply-with',RepWith1])).

/*******************************
code to make messages to the ps and omgr
*******************************/

makeoutput(ID,'sa-yn-question',if,ID9) :-
    assoc_msgs(ID,[ID,ID1,ID2]),
    assert_head(ID9,express),		  
    kqml_kv(ID1,[':aspect',Aspect]),
    ireq(sem(ID,Sem),ID),
    ireq(lsubj(Sem,Lsubj),ID),
    (ireq(lobj(Sem,Lobj),ID);true),
    ireq(lf(Sem,LF),ID),
%    getallbindings(ID,Bindings),
    %use them to determine whether to affirm/deny
    %if all vars in LF are bound affirm
    %determine focus on this basis
    subst(ID,dreq,false,Lsubj,Lsubj1),
    recsubst(ID,dreq,false,LF,LF1),
    assert_expr(ID3,LF1),!,
    (getvars(LF1,[]),
    oassert(kqml_kv(ID9,[':speech-act',affirm])),
    Focus = [Lsubj1],
    oassert(kqml_kv(ID9,[':content',ID3]));
    oassert(kqml_kv(ID9,[':speech-act',deny])),
    assert_expr(ID5,[not, ID3]),
    oassert(kqml_kv(ID9,[':content',ID5])),
    LF1 = [_,_|Focus]),
    assert_expr(ID6,Focus),
    oassert(kqml_kv(ID9,[':focus',ID6])),
    oassert(kqml_kv(ID9,[':media',unspecified])),
    findall(ConID,(ireq(psConstraint(ID,_,PSConstraint),ID), 
    recsubst(ID,dreq,false,PSConstraint,PSConstraint1),
    LF1 \== PSConstraint1, \+ clause(kqml_expr(_,PSConstraint1),true),
    assert_expr(ConID,PSConstraint1)),ConIDs),
    makevarconstraints(ID,VarIDs),
    append(VarIDs,ConIDs,ConVarIDs),
    assert_expr(ID7,[and|ConVarIDs]),
    oassert(kqml_kv(ID9,[':constraints',ID7])),
    assert_msg(ID9,dm,outmgr,ID,ID9).

makeoutput(ID,'sa-wh-question',one,ID9) :-
assoc_msgs(ID,[ID,ID1,ID2]),
assert_head(ID9,express),
%get the original aspect
kqml_kv(ID1,[':aspect',Aspect]),
%get the constraint representing the parser output lf;
ireq(sem(ID,Sem),ID),
ireq(lsubj(Sem,Lsubj),ID),
(ireq(lobj(Sem,Lobj),ID);true),
ireq(lf(Sem,LF),ID),
oassert(kqml_kv(ID9,[':speech-act',reply])),
%use them to determine whether to affirm/deny
%if all vars in LF are bound affirm
%determine focus on this basis
subst(ID,dreq,false,Lsubj,Lsubj1),
recsubst(ID,dreq,false,LF,LF1),
assert_expr(ID3,LF1),
(getvars(LF1,[]) -> 
 (LF1 = [_,_|Focus],
  assert_expr(ID6,Focus),
  oassert(kqml_kv(ID9,[':content',ID3])));
 ( assert_expr(ID5,[not, ID3]),
  oassert(kqml_kv(ID9,[':content',ID5])),
  assert_expr(ID6,[]))),
oassert(kqml_kv(ID9,[':focus',ID6])),
oassert(kqml_kv(ID9,[':media',unspecified])),
findall(ConID,(psConstraint(ID,_,PSConstraint), 
recsubst(ID,dreq,false,PSConstraint,PSConstraint1),
 LF1 \== PSConstraint1,
 assert_expr(ConID,PSConstraint1)),ConIDs),
 makevarconstraints(ID,VarIDs),
 append(VarIDs,ConIDs,ConVarIDs),
assert_expr(ID7,[and|ConVarIDs]),
oassert(kqml_kv(ID9,[':constraints',ID7])),
assert_msg(ID9,dm,outmgr,ID,ID9).

%this doesn't work anymore - changed lf and lfs
makeoutput(ID,'sa-wh-question',all,ID9) :-
assoc_msgs(ID,[ID,ID1,ID2]),
assert_head(ID9,express),
%get the original aspect
kqml_kv(ID1,[':aspect',Aspect]),
%get the constraint representing the parser output lf;
ireq(sem(ID,Sem),ID),
ireq(lsubj(Sem,Lsubj),ID),
(ireq(lobj(Sem,Lobj),ID);true),
ireq(lf(Sem,LF),ID),
oassert(kqml_kv(ID9,[':speech-act',inform])),
recsubst(ID,dreq,false,LF,LF1),
subst(ID,dreq,false,Lsubj,Lsubj1),
%get the set of fully bound Bindings
findall(X,(member(X,LFs),getvars(X,[])),LF1s),
findall(ID3,(member(X,LF1s),assert_expr(ID3,X)),ID3s),
assert_expr(ID4,[and|ID3s]),
(ID3s \== [] -> 
 (findall(Focus,(member(X,LF1s),X = [_,Focus,_]),Foci),
  assert_expr(ID5,Foci),
  assert_expr(ID6,Foci),
  oassert(kqml_kv(ID9,[':content',ID4])));
 (LFs = [LF1|Rest],
  assert_expr(ID7,LF1),
  assert_expr(ID8,[not, ID7]),
  oassert(kqml_kv(ID9,[':content',ID8])),
  LF = [Focus,_,_],
  assert_expr(ID6,Focus))),
oassert(kqml_kv(ID9,[':focus',ID6])),
oassert(kqml_kv(ID9,[':media',unspecified])),
findall(ConID,(psConstraint(ID,_,PSConstraint), 
 LF \== PSConstraint,
 multsubst(ID,dreq,false,PSConstraint,PSConstraints),
 member(PSConstraint1,PSConstraints),
 assert_expr(ConID,PSConstraint1)),ConIDs),
 makevarconstraints(ID,VarIDs),
 append(VarIDs,ConIDs,ConVarIDs),
assert_expr(ID7,[and|ConVarIDs]),
oassert(kqml_kv(ID9,[':constraints',ID7])),
assert_msg(ID9,dm,outmgr,ID,ID9).

makevarconstraints(ID,Phase,VarIDs) :-
findall(Var,(Q =.. [Phase,ID,obj(ID,Var)],clause(Q,true)),Vars),
recsubst(ID,Phase,false,Vars,Vars1),
getvars(Vars1,Vars2),
makevarconstraints1(Vars2,VarIDs).

makevarconstraints1([Var|Vars],VarIDs) :-
assert_expr(ID,[var, Var]),
makevarconstraints1(Vars,VarIDs1),
VarIDs = [ID|VarIDs1].
makevarconstraints1([],[]).

makenewsubplanreq(ID,ID1) :-
ireq(sem(ID,Sem),ID),
ireq(lsubj(Sem,Lsubj),ID),
(ireq(lobj(Sem,Lobj),ID);true),
ireq(lf(Sem,LF),ID),
%get all bindings
subst(ID,dreq,false,Lsubj,Lsubj1),
subst(ID,dreq,false,Lobj,Lobj1),
recsubst(ID,dreq,false,LF,LF1),
makePSPlanContent(ID,dreq,ID4),
assert_head(ID5,':new-subplan'),
oassert(kqml_kv(ID5,[':plan-id',r341])),
oassert(kqml_kv(ID5,[':content',ID4])),
assert_ps_msg('request',dm,ps,ID,ID1,[],ID5,[],[],ID1).


%convert parser constraints to PS constraints
%later we will reprocess some constraints 
%from parser representation to PS representation
makePSConstraints(ID) :-
findall(Constraint,ireq(constraint(ID,Constraint),ID),Constraints),
makePSConstraints(ID,Constraints).

makePSConstraints(ID,[Constraint|Constraints]) :-
Constraint = [Pred|Args],
(Pred == class;
 Pred == 'at-loc'),
recsubst(ID,ireq,false,Args,Args1),
%convert_vars(Args1,Args2),
%toexplore: a ! here causes the predicate to fail if any of below fails
( ((Pred == class,Args1 = [X,Y],Y == engine) -> 
  oassert(dreq(psConstraint(ID,Constraint,[type|Args1]),ID)));
  ((Pred == class,Args1 = [X,Y],Y == train) -> 
   oassert(dreq(psConstraint(ID,Constraint,[type,X,engine]),ID)));
  ((Pred == class,Args1 = [X,Y],Y == location) -> 
   oassert(dreq(psConstraint(ID,Constraint,[type,X,city]),ID)));
  ((Pred == class,Args1 = [X,Y],Y == city) -> 
   oassert(dreq(psConstraint(ID,Constraint,[type,X,city]),ID)));
  (Pred == 'at-loc' -> 
   oassert(ireq(psConstraint(ID,Constraint,['at-loc'|Args1]),ID)));
  true),!,
makePSConstraints(ID,Constraints).
%some constraints are not transmitted to the PS
makePSConstraints(ID,[_|Constraints]) :-
makePSConstraints(ID,Constraints).
makePSConstraints(ID,[]).

/*
MUST CONSTRUCT
(REQUEST :RE 2 :REPLY-WITH RQ178 :SENDER dm :RECEIVER PS :CONTENT (:NEW-SUBPLAN :PLAN-ID R341 :CONTENT (:GO GO177 (:AND (:AGENT ENGINE_3) (:TO CHARLESTON)))))
*/
%make the set of variables for dumpty to bind
makePSAspects(ID,PSAspects) :-
makePSAspects1(ID,PSAspects),
oassert(dreq(psAspects(ID,PSAspects),ID)).

makePSAspects1(ID,PSAspects) :-
getbindings(ID,ireq,Bindings),
makePSAspects1(ID,Bindings,PSAspects).

makePSAspects1(ID,[Binding|Bindings],PSAspects) :-
((Binding = [Obj,null], ireq(obj(ID,Obj),ID)) ->
    PSAspect = [Obj];
%   (convert_var(Obj, Obj1),)
   PSAspect = []),
makePSAspects1(ID,Bindings,PSAspects1),
append(PSAspect,PSAspects1,PSAspects).
makePSAspects1(ID,[],[]).

makePSPlanContent(ID,Phase,ID1) :- 
ireq(sem(ID,Sem),ID),
ireq(class(Sem,Class),ID),
(Class = move -> 
 (PSClass = ':go', gensym('go',PSVar))),
%agent
ireq(lobj(Sem,Lobj),ID),
subst(ID,Phase,false,Lobj,Lobj1),
assert_expr(ID3,[':agent',Lobj1]),
ireq(path(ID,Path),ID),
(ireq(to(Path,To),ID) ->
 (subst(ID,Phase,false,To,To1),
  assert_expr(ID4,[':to',To1]));true),
((ireq(from(Path,From),ID);ireq('at-loc'(Lobj1,From),ID)) ->
 (subst(ID,Phase,false,From,From1),
  assert_expr(ID5,[':from',From1]),
  assert_expr(ID6,[':and',ID3,ID4,ID5]));
  assert_expr(ID6,[':and',ID3,ID4])),
assert_expr(ID1,[PSClass,PSVar,ID6]).

%this may be incorrect now for ps
makeupdateplanreq(ID,ID1) :-
done(ah_reqnewsubplan(ID,all,ID2,_,_),_),
psreply(ID2,ID3),
kqml_kv(ID3,['content', ID4]),
kqml_kv(ID4,['result', ID5]),
kqml_kv(ID4,['ps-state', PSState]),
kqml_kv(ID5,['plan', ID6]),
kqml_expr(ID6,[Plan|_]),
assert_expr(ID7,[':update-pss',':ps-state',PSState]),
assert_ps_msg('request',dm,ps,ID,ID1,[],ID7,[],[],ID1).

makeoutput(ID,'sa-request','new-subplan',ID30) :-
done(ah_reqnewsubplan(ID,all,ID2,_,_),_),
psreply(ID2,ID4),
assert_head(ID30,express),
oassert(kqml_kv(ID30,[':speech-act','inform_plan'])),
gensym(path,Path),
assert_expr(ID8,[Path]),
oassert(kqml_kv(ID30,[':focus',ID8])),
oassert(kqml_kv(ID30,[':media',unspecified])),
ireq(sem(ID,Sem),ID),
ireq(lf(Sem,[_,Lobj,_]),ID),
PSConstraint1 = [type,Lobj,engine],
recsubst(ID,dreq,false,PSConstraint1,PSConstraint2),
subst(ID,dreq,false,Lobj,Lobj1),
assert_expr(ID9,PSConstraint2),
PSConstraint3 = [type,Path,route],
assert_expr(ID10,PSConstraint3),
kqml_kv(ID4,['content', ID11]),
kqml_kv(ID11,['result', ID12]),
kqml_kv(ID12,['plan', ID13]),
kqml_expr(ID13,[_,'goal',ID14,_,_,'actions',ID15|_]),
kqml_kv(ID14,['to',To]),
kqml_kv(ID14,['from',From]),
gettracks(ID15,Tracks),
PSConstraint4 = [source,Path,From],
assert_expr(ID18,PSConstraint4),
PSConstraint5 = [dest,Path,To],
assert_expr(ID19,PSConstraint5),
assert_expr(ID20,Tracks),
assert_expr(ID21,[tracks,Path,ID20]),
assert_expr(ID22,[and,ID9,ID10,ID18,ID19,ID21]),
oassert(kqml_kv(ID30,[':constraints',ID22])),
PSConstraint6 = ['move-engine-along-path',Lobj1,Path],
subst(ID,dreq,false,PSConstraint6,PSConstraint7),
assert_expr(ID23,PSConstraint7),
oassert(kqml_kv(ID30,[':content',ID23])),
assert_msg(ID30,dm,outmgr,ID,ID30).

gettracks(ID,Tracks) :-
kqml_expr(ID,ActionIDs),
findall(Track,
(member(ActionID,ActionIDs),
kqml_expr(ActionID,['go',_,_,_,ID1]),
kqml_expr(ID1,['track',Track])),
Tracks).

/****************
code to deal with bindings of utterance variables
*****************/

makepsbindings(ID,ID1) :-
makepsbindings(ID,ID1,Bindings),
makepsbindings1(ID,ID1,Bindings).

makepsbindings1(ID,ID1,[Binding|Bindings]) :-
Binding = [Var,[Val]],
(dreq(lex(Var,_),ID) ->
 oretractall(dreq(lex(Var,_),ID));
 true),
oassert(dreq(lex(Var,Val),ID)).
makepsbindings([]).
 
%need to update this to obtain multiple bindings, not just one
makepsbindings(ID,ID1,Bindings) :-
    kqml_kv(ID1, [content, ContentID]),
    kqml_kv(ContentID, [vars, VarID]),
    kqml_expr(VarID,VarList),
    kqml_kv(ContentID, [result, ResultID]),
    unconvert_vars(VarList,VarList1),
    (ResultID == 'nil',length(VarList1,Len),
     blanklists(Len,ResultListList1),
     ResultListList = [ResultListList1];
     kqml_expr(ResultID,ResultIDList),
      getresultlistlist(ResultIDList, ResultListList)),
      append([VarList1],ResultListList,VarsnResults),
      transpose(VarsnResults,Bindings1),
      addlists(Bindings1,Bindings).

%make dummy lists in order to make the transpose work for null bindings
blanklists(Len,[]) :-
Len =< 0.
blanklists(Len,ListList) :-
    Len1 is Len - 1,
     ListList1 = [[]],
     blanklists(Len1,ListList2),
     append(ListList1,ListList2,ListList).

%the results are either a list of different possible binding lists
%or just one binding list
getresultlistlist([R|ResultIDList],ResultListList) :-
    ((is_kqml_var(R),
     kqml_expr(R,ResultList),
     getresultlistlist(ResultIDList,ResultListList1),
     append([ResultList],ResultListList1,ResultListList));
     ResultListList = [[R|ResultIDList]]).
getresultlistlist([],[]).
addlists([[V|Binds]|Rest],Bindings) :-
     Bindings1 = [[V|[Binds]]],
     addlists(Rest,Bindings2),
     append(Bindings1,Bindings2,Bindings).
addlists([],[]).

%************************************

%might need to make this recursive
%returns the set of Vals formed by substituting 
%in Lex values for Vars
multsubst(ID,Phase,RepNulls,[Var|Vars],Vals) :-
subst(ID,Phase,RepNulls,Var,Val),
multsubst(ID,Phase,RepNulls,Vars,Vals1),
Vals = [Val|Vals1].
multsubst(_,_,_,[],[]).

recsubst(ID,Phase,RepNulls,[Var|Vars],Vals) :- 
(is_list(Var) -> recsubst(ID,Phase,Var,Val1);
 subst(ID,Phase,RepNulls,Var,Val1)),
recsubst(ID,Phase,RepNulls,Vars,Vals1),
Vals = [Val1|Vals1].
recsubst(_,_,_,[],[]).

%find the proper name for Arg in the list of Obj - Name 
%bindings and replace Arg with it
subst(ID,Phase,RepNulls,Var,Var1) :-
((Q =.. [Phase,lex(Var,Var1),ID],clause(Q,true),(\+ Var1 = null; RepNulls = true));
 Var1 = Var).

%getvars recursively finds the vars in a structure
getvars([Arg|Args],Vars) :-
is_list(Arg),
getvars(Arg,Vars1),
getvars(Args,Vars2),
append(Vars1,Vars2,Vars).
getvars([Arg|Args],Vars) :-
(is_var(Arg) -> Vars1 = [Arg];
 Vars1 = []),
getvars(Args,Vars2),
append(Vars1,Vars2,Vars).
getvars([],[]).

is_var(Obj) :-
atom(Obj),
%(atom_chars(Obj,[63,118,97,114|Rest]);
(atom_chars(Obj,[63,118|Rest]);
atom_chars(Obj,[118|Rest])),
number_chars(_,Rest).


%convert vars from parser format to PS format
convert_vars([Arg|Args],Args1) :- 
(is_list(Arg) -> convert_vars(Arg,Arg1);
 convert_var(Arg,Arg1)),
convert_vars(Args,Args2),
Args1 = [Arg1|Args2].
convert_vars([],[]).

%convert vars from parser format to PS format
unconvert_vars([Arg|Args],Args1) :- 
(is_list(Arg) -> convert_vars(Arg,Arg1);
 unconvert_var(Arg,Arg1)),
unconvert_vars(Args,Args2),
Args1 = [Arg1|Args2].
unconvert_vars([],[]).

%%cfa need to check if this is working on correct things
%this converts var constants into similar strings beginning with "?"
%%it also adds a colon to various constants to meet PS specs
convert_var(Arg,Arg1) :- 
convert1_var(Arg,Arg1);
((\+ (convert1_var(Arg,Arg1), 
      Arg \== Arg1)),
Arg = Arg1).

convert1_var(Arg,Arg1) :- 
atom(Arg),
atom_chars(Arg,ArgStr),
% v + digit....
(ArgStr = [118|Rest],
number_chars(_,Rest),
ArgStr1 = [63,118|Rest]),
atom_chars(Arg1,ArgStr1).

convert1_var(Arg,Arg1) :- 
atom(Arg),
((Arg = 'at-loc' -> Arg1 = ':at-loc');
 (Arg = 'type' -> Arg1 = ':type');
 (Arg = 'engine' -> Arg1 = ':engine');
 (Arg = 'city' -> Arg1 = ':city')
).

unconvert_var(Arg,Arg1) :- 
unconvert1_var(Arg,Arg1);
((\+ (unconvert1_var(Arg,Arg1), 
      Arg \== Arg1)),
Arg = Arg1).

unconvert1_var(Arg,Arg1) :- 
atom(Arg),
atom_chars(Arg,ArgStr),
ArgStr = [63,118|Rest],
number_chars(_,Rest),
ArgStr1 = [118|Rest],
atom_chars(Arg1,ArgStr1).

%get and assert the known object - name pairs
makebindings(ID) :-
findall(Obj,ireq(obj(ID,Obj),ID),Objs),
makebindings(ID,Objs).

makebindings(ID,[Obj|Objs]) :-
(ireq(lex(Obj,Lex),ID);
oassert(ireq(lex(Obj,'null'),ID))),
makebindings(ID,Objs).
makebindings(_,[]).

%get all the known object - name pairs
getbindings(ID,Phase,Bindings) :-
findall(Obj,(Q =.. [Phase,obj(ID,Obj),ID],clause(Q,true)),Objs),
getbindings1(ID,Objs,Bindings).

getbindings1(ID,[Obj|Objs],Bindings) :-
((ireq(lex(Obj,Lex),ID) -> Binding1 = [Obj,Lex]);
 Binding1 = [Obj,null]),
getbindings1(ID,Objs,Bindings1),
Bindings = [Binding1|Bindings1].
getbindings1(_,[],[]).

duplist(El,0,[]).
duplist(El,Num,Els) :-
Num1 is Num - 1,
duplist(El,Num1,Els1),
append([El],Els1,Els).

/*********************
dm initialization and reset functions
**********************/

dm_init :- 
%domain-dependent assertions
!,
assert(domain_pred1('sa-request')),
assert(domain_pred1('speech-act')),
assert(domain_pred1('sa-yn-question')),
assert(domain_pred1('sa-wh-question')),
assert(domain_pred1('reply')),
assert(domain_pred1('find-plans-bindings')),
assert(domain_pred1('new-subplan')),
assert(domain_pred1('update-pss')),
assert(domain_pred1('pss-update')),
assert(domain_pred1('answer')),
assert(domain_pred1('express')),
assert(domain_pred1('plan-updated')),
assert(domain_pred1('new-subplan')),
assert(domain_pred1(tell)),
assert(domain_pred1(quit)),
assert(domain_pred1(restart)),
assert(domain_pred2(description)),
assert(domain_pred2('path')),
assert(domain_pred2('prop')),
assert(domain_pred2(go)),
assert(remove_leading_colon),!,
assert(use_kvs),!,
assert(use_kv2s),!.
%dm_init1.

dm_init1 :-
sendmsg1(['TELL :RECEIVER IM :CONTENT (READY)']),
sendmsg1(['REQUEST :SENDER DM :RECEIVER IM :CONTENT (LISTEN PARSER)']).

/*
retraction code
*/

%retract the assertions about utterance ID
make_retracts(ID) :-
kqml_retract(ID),
retractall(ireq(lex(_,_),ID)),
retractall(ireq(aPSPair(_,_),ID)),
retractall(ireq(newname(_,_),ID)),
retractall(ireq(aPSAction(_,_),ID)),
retractall(ireq(aPSContent(_,_),ID)),
retractall(ireq(aPSType(_,_),ID)),
retractall(ireq(aPSCommand(_,_),ID)),
retractall(ireq(psAspects(_,_),ID)),
retractall(ireq(psConstraint(_,_,_),ID)),
retractall(ireq(bindings(_,_),ID)),
retractall(ireq(lcomp(_,_),ID)),
retractall(ireq(lobj(_,_),ID)),
retractall(ireq(lsubj(_,_),ID)),
retractall(ireq(sem(_,_),ID)),
retractall(ireq(to(PPath,To),ID)),
retractall(ireq(constraint(_,_),ID)),
retractall(ireq(from(_,_),ID)),
retractall(ireq(path(_,_),ID)),
retractall(ireq(at-loc(_,_),ID)),
retractall(ireq(constraint(_,_),ID)),
retractall(ireq(lex(_,_),ID)),
retractall(ireq(constraint(_,_,_),ID)),
retractall(ireq(class(_,_),ID)),
retractall(ireq(obj(_,_),ID)),
retractall(ireq(focus(_,_),ID)),
retractall(ireq(type(_,_),ID)),
retractall(ireq(sort-of(_,_),ID)),
retractall(ireq(msg(_,_),ID)),
retractall(ireq(status(_,_),ID)),
retractall(ireq(lf(_,_),ID)),
retractall(ireq(curr_utt(_),ID)),
retractall(dreq(lex(_,_),ID)),
retractall(dreq(aPSPair(_,_),ID)),
retractall(dreq(newname(_,_),ID)),
retractall(dreq(aPSAction(_,_),ID)),
retractall(dreq(aPSContent(_,_),ID)),
retractall(dreq(aPSType(_,_),ID)),
retractall(dreq(aPSCommand(_,_),ID)),
retractall(dreq(psAspects(_,_),ID)),
retractall(dreq(psConstraint(_,_,_),ID)),
retractall(dreq(bindings(_,_),ID)),
retractall(dreq(lcomp(_,_),ID)),
retractall(dreq(lobj(_,_),ID)),
retractall(dreq(lsubj(_,_),ID)),
retractall(dreq(sem(_,_),ID)),
retractall(dreq(to(PPath,To),ID)),
retractall(dreq(constraint(_,_),ID)),
retractall(dreq(from(_,_),ID)),
retractall(dreq(path(_,_),ID)),
retractall(dreq(at-loc(_,_),ID)),
retractall(dreq(constraint(_,_),ID)),
retractall(dreq(lex(_,_),ID)),
retractall(dreq(constraint(_,_,_),ID)),
retractall(dreq(class(_,_),ID)),
retractall(dreq(obj(_,_),ID)),
retractall(dreq(focus(_,_),ID)),
retractall(dreq(type(_,_),ID)),
retractall(dreq(sort-of(_,_),ID)),
retractall(dreq(msg(_,_),ID)),
retractall(dreq(status(_,_),ID)),
retractall(dreq(lf(_,_),ID)),
retractall(dreq(curr_utt(_),ID)).

/***********************************
special code to assert expressions in ALMA
******************************/

assert_expr(ID,Exprs) :- !,
gensym(kqml,ID),
oassert(kqml_expr(ID,Exprs)).

assert_head(ID,Head) :-
gensym(kqml,ID),
oassert(kqml_head(ID,Head)).

assert_msg(ID,Sender,Receiver,Re,Repwith) :-
oassert(kqml_kv(ID,[':sender',Sender])),
oassert(kqml_kv(ID,[':receiver',Receiver])),
kqml_to_msg(Re,Re1),
kqml_to_msg(Repwith,Repwith1),
oassert(kqml_kv(ID,[':re',Re1])),
oassert(kqml_kv(ID,[':reply-with',Repwith1])).

%these are assertions in kqml.pl
%oassert(Form) :-
%(clause(Form,true); (af(Form),assert(Form))).

%af(Term) :- true.

/*********************
utility functions
*********************/

%gets the part of the input list structure which is bound to Var
getvarbinding(Var,Msg,Binding) :-
getitem(Msg,Var,Item,1),
Binding = [Var,Item].

%looks breadth-first inside Object for the list called Item that begins with Label
%if Num is anything other than 0 the Numth member of the list is returned as Item
getitem(O,Label,Item,Num) :-
getitem1([O],Label,Item,Num).
getitem1([O|Objs],Label,Item,Num) :-
O = [X|_],
X = Label,
Num > 0,
getnth(O,Num,Item).
getitem1([O|Objs],Label,Item,Num) :-
O = [X|Y],
X = Label,
Num =:= 0,
Item = O.
getitem1([O|Objs],Label,Item,Num) :-
O = [X|Y],
\+ X = Label,
append(Objs,O,NewObjs),
getitem1(NewObjs,Label,Item,Num).
getitem1([O|Objs],Label,Item,Num) :-
\+ O = [X],
getitem1(Objs,Label,Item,Num).

%looks through a list to find the Numth Object after Label
%if Num is 0 then the remainder of the list is returned
getlistitem([O|Objs],Label,Item,Num) :-
O = Label,
Num == 0,
Item = [O|Objs].
getlistitem([O|Objs],Label,Item,Num) :-
O = Label,
getnth([O|Objs],Num,Item).
getlistitem([O|Objs],Label,Item,Num) :-
getlistitem(Objs,Label,Item,Num).

getnth([X|Xs],N,Obj) :-
N == 0,
Obj = X.
getnth([X|Xs],N,Obj) :-
N > 0,
N1 is N - 1,
getnth(Xs,N1,Obj).

%given a set, a predicate, an arg, return members of set that satisfy predicate
%set-sat(Set,Pred,Arg,NewSet)

%takes a list and returns first member
car([First|_],First).
%takes a list and returns rest of list besides first member
cdr([_|Rest],Rest).

%necessary because one cannot use 'kqml___' in a msg
%obsolete version
kqml_to_msg(Kqml,Msg) :-
atom(Kqml),
atom_chars(Kqml,[107,113,109,108|Rest]),
atom_chars(Msg,[109,115,103|Rest]).

%current version that changes kqml cars into constants
%by adding a "\"
kqml_const(Kqml,Kqmlconst) :-
atom(Kqml),
atom_chars(Kqml,Chars1),
Chars2 = [92|Chars1],
atom_chars(Kqmlconst,Chars2).

msg_to_kqml(Msg,Kqml) :-
atom(Msg),
atom_chars(Msg,[109,115,103|Rest]),
atom_chars(Kqml,[107,113,109,108|Rest]).

%used to assert formulas which are not to be passed on to alma
%if Var is uninstantiated do nothing.
passertall(Var) :-
var(Var).

passertall([A|Asserts]) :-
passert(A),
passertall(Asserts).
passertall([]).

passert(Form) :-
(clause(Form,true); 
 assert(Form)).

% do nothing for now
pretractall([A|Asserts]) :-
pretract(A),
pretractall(Asserts).
pretractall([]).

pretract(Form) :-
(retractall(Form);
 true).





