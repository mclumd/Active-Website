<HTML>
<HEAD>
<TITLE>UMCP Computer Science: Primer on Active Logic</TITLE>
</HEAD>
<BODY>

<BODY bgcolor="#ffffff" text="#000000" link="#FFFF00" vlink="#CCAA00">
 
<basefont size=3>
<p>
<font size=+2>
<!img src="/projects/active/picts/al_quarter_logo.gif" align=right hspace=0>
An Example Active Logic.

</font>

<hr>
<p>
<br>

There are several examples of active logics in our papers. We present
here a couple of simple examples.

<p>

<pre>

       t:     Now(t)
            ----------
       t+1:  Now(t+1)
</pre>

is a rule that says: if at the current step, Now has the value t,
then, at the next step, let Now have the value (t + 1). This enables
the active logic to keep track of step numbers and therefore of time.
<p>

This is a basic rule and is included in all active logics. 

<p>
<hr>

Another example is the contradiction rule:
<pre>

       t:      P, not(P)
             -----------------
       t+1:  contra(P, not(P))
</pre>

If at a step, we have both P and not(P) present in the database, at
the next step, we add contra(P, not(P)) to the database to indicate
the contradiction. There will be other rules that will cause the
consequences of P and not(P) not to be derived in later steps, and
rules that will attempt to resolve the contradiction and reinstate
either P or not(P) to the database at a later time. 
<p>
<hr>

We can also have modus ponens:
<pre>

      t:       P, P -> Q
            --------------
      t+1:        Q
</pre>

This says: if at time t, the database contains P and (P -> Q), then in
the next time step, conclude Q.
<p>
Note that if the database contains P, (P -> Q) and (Q -> R), we do not
get R immediately, but only after 2 steps. First, we use P and (P ->
Q) to obtain Q, then in the second step, we use this together with (Q
-> R) to derive R.

<hr>
The inheritance rule keeps formulas in the database unless there is a
contradiction: 
<pre>

      t:        P , not_know(not(P)), \+ P = Now(t)
	      -------------------------------------
      t + 1:                    P

      t:           P , not_know(P)
	      ------------------------
      t + 1:            not(P)
</pre>

not_know(P) is true iff P is not in the current database. Since the
database is finite, this poses no computational problems. "\+ P =
Now(t)" verifies that P is not of the form Now(t) and prevents time
form being inherited.
<p>
This pair of rules causes contradictions not to be present after they
are detected.
   

<hr>
<p>
Let the sentences initially present in the database be: Now(0),
Bird(tweety), Bird(x) & not_know(not(fly(x))) -> fly(x). With the
above rules of inference, this is what the database looks like at
consecutive steps:
<p>
At step 0: 
Now(0), Bird(tweety), Bird(x) & not_know(not(fly(x))) -> fly(x)
<p>
At step 1:
Now(1), Bird(tweety), Bird(x) & not_know(not(fly(x))) -> fly(x),
fly(tweety) 
<p>
since "not(fly(tweety))" is not present in the database at step 0.
<p>
The database will not change thereafter.
<p>
<hr>
Now assume that the initial set of sentences is: Now(0),
Bird(tweety), Bird(x) & not_know(not(fly(x))) -> fly(x),
not(fly(tweety)).
<p>
This time we get:
<p>
At step 0: 
Now(0), Bird(tweety), Bird(x) & not_know(not(fly(x))) -> fly(x),
not(fly(tweety)) 
<p>
At step 1:
Now(1), Bird(tweety), Bird(x) & not_know(not(fly(x))) -> fly(x),
not(fly(tweety)) 
<p>
This time, we cannot conclude that tweety flies since we know he
doesn't, i.e., not_know(not(fly(tweety))) fails since not(fly(tweety))
is present at step 0.






<hr>

</body>
</html>
